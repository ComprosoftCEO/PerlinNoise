# Perlin Noise
N-Dimensional Perlin Noise Generator

<br>

## About
[Perlin Noise](https://en.wikipedia.org/wiki/Perlin_noise) is a function that returns a number from 0.0 to 1.0 for a given coordinate in N-dimensions (but usually 2 or 3 dimensions). This Perlin Noise library is designed to be simple to use, portable, and cross-platform. Code is written and compiled using the [CodeBlocks IDE](http://www.codeblocks.org/) and is based on the article [Understanding Perlin Noise](http://flafla2.github.io/2014/08/09/perlinnoise.html).

<br>

## Using the DLL Library
To initialize Perlin Noise for use on a given thread, call the function
```c
DLL_EXPORT int init_perlin();
```
<br>

When you are done using Perlin Noise, you can release all allocated resources by calling
```c
DLL_EXPORT int release_perlin();
```

<br>

*For multi-threaded applications, these functions needs to be called for each thread in the application.*

<br>

## Functions Supported
This DLL library has function calls for 1D, 2D, and 3D Perlin Noise. However, the internal Perlin object is designed to work with any number of dimensions. Adding support for higher dimensional Perlin Noise is a trivial matter, and merely requires having more parameters and a larger array of doubles.  

The main functions for generating Perlin Noise are as follows:
```C
DLL_EXPORT double get_1d_perlin(double x);
DLL_EXPORT double get_2d_perlin(double x, double y);
DLL_EXPORT double get_3d_perlin(double x, double y, double z);

DLL_EXPORT double get_1d_perlin_octave(double x,
                                       uint32_t octaves, double persistance);
                                       
DLL_EXPORT double get_2d_perlin_octave(double x, double y,
                                       uint32_t octaves, double persistance);
                                       
DLL_EXPORT double get_3d_perlin_octave(double x, double y, double z,
                                       uint32_t octaves, double persistance);
```

<br>

## Seeding Perlin Noise
Perlin Noise uses a custom pseudo-random number generator known as Rand64 (Taken from [Hexacrypt-API](https://github.com/ComprosoftCEO/Hexacrypt-API)). The internal random number generator can be seeded with a 64-bit unsigned integer by calling:
```c
DLL_EXPORT void seed_perlin_1d(uint64_t seed);
DLL_EXPORT void seed_perlin_2d(uint64_t seed);
DLL_EXPORT void seed_perlin_3d(uint64_t seed);
```
Additionally, a random seed can be used by calling:
```c
DLL_EXPORT void random_perlin_1d();
DLL_EXPORT void random_perlin_2d();
DLL_EXPORT void random_perlin_3d();
```

<br>

## Perlin Object
All Perlin Noise is generated by the internal Perlin object (defined in Perlin.c). A new Perlin object can be created by calling:
```c
pPerlin_t new_perlin(pSize dimensions);
pPerlin_t new_perlin_seed(pSize dimensions, uint64_t seed);
```
After usage, don't forget to free the object using
```c
void free_perlin(pPerlin_t p);
```
Coordinates are passed into the object using an array of doubles. Be sure the depth of the array matches the dimensions of the Perlin object, or segmentation faults might occur. Noise can be generated by calling:
```c
double perlin_noise(pPerlin_t p, const double* coords);
double perlin_noise_octave(pPerlin_t p, const double* coords, uint32_t octaves, double persistence);
```
Additionally, the Perlin object can be given a different seed using:
```c
void reseed_perlin(pPerlin_t p, uint64_t seed);
void random_seed_perlin(pPerlin_t p);
```
The object is designed to scale well under higher dimensions (even if it gets exponentially slower to calculate) by using a counter of bytes and small temporary data storage. The counter is used to calculate the points of the N-dimensional cube, specify how to find the internal vectors, and tell when to interpolate previously calculated the dot products.

An algorithm named Hash8 is used when generating the gradient vectors (Taken from [Hexacrypt-API](https://github.com/ComprosoftCEO/Hexacrypt-API) and based on [Pearson Hashing](https://en.wikipedia.org/wiki/Pearson_hashing)). The 64-bit integer returned from Hash8 is used to seed a Rand64 object (Also taken from [Hexacrypt-API](https://github.com/ComprosoftCEO/Hexacrypt-API)), and the Rand64 does the actual coordinate generation.
